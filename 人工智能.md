感知机：第二层权重依赖第一层决策结果，并输出更抽象的决策结果。
回归模型可预测连续值。
分类模型可预测离散值。
损失：如果模型的预测完全准确，则损失为零，否则损失会较大。样本点离预测线越远，损失越大。
平方损失：(y-y)^2 平方形式的时候，使用的是“最小二乘法”的思想，
wb初始值：在非凸形的有多个最低点时，选初始值很重要。线性回归无所谓选0既可。
收敛：损失不再变化或变化极其缓慢为止。可以说该模型已收敛。

### Rx.js 响应式编程
应用场景：
  1. 搜索框：Rx.Observable.fromEvent(input, 'keyup').debounce(250).pluck('target', 'value').flatMapLatest(url => Http.get(url)).subscribe(data => render(data))
  2. 前端缓存和异步逻辑统一：
```
    function getData() {
  	  if (a) {
    	return Observable.of(a) //Promise.resolve(a)
  	  } else {
    	return Observable.fromPromise(AJAX.get('a')) //AJAX.get('a')
  	  }
	}
```
特点：
  1. 使用RxJS的代码消除了一些中间变量，使用操作符来分步执行逻辑，可读性更强、耦合性更低，更方便测试和修改。Rx中是永远不保留状态的。
  2. 消费者用迭代器协议通知生产者继续发送数据。
  3. 生产者叫做Observables, 消费者叫做Observer(subscribe里面的方法)。管道中的函数叫做observable operators
  4. observables是个不可变数据类型，像string一样；
  5. observables不仅仅代表了当前时刻的数据，也代表了未来某时刻的数据。
  6. Observable是惰性求值的，不像Promise创建即开始运行。
  7. 单一职责：对于UI来说，它只关心数据输入，不关心数据怎么来的。类似server.on('task',=>) server.getdata()
  8. 现在未来：进入本列表的数据都应当经过某种过滤规则和某种排序规则
  9. MDV（模型驱动视图）：一切对于视图的变更，首先都应当是模型的变更，然后通过模型和视图的映射关系，自动同步过去。
  10. 叠加态：如果把视图的状态理解为一个时间轴上的流，它可以被视为若干个其他流的叠加，这么多流叠加起来，在当前时刻的值，就是能够表达我们所见视图的全部状态数据。
命令式：判断状态
响应式：
Stream就是Observable
每个数据事件到达时，被Stream监听到。
Promise 就是只有一个映射值的 Observable。Rx Stream 比 Promise 更进一步的是允许返回多个值。
流中流：主流每个映射值都是分支流
requestStream:  --a-----b--c------------|->
responseStream: -----A--------B-----C---|->
```
var requestStream = Rx.Observable.just('https://api.github.com/users');
    var responseStream = requestStream
    .flatMap(function(requestUrl) {
        return Rx.Observable.fromPromise(jQuery.getJSON(requestUrl));
    });
    responseStream.subscribe(function(response) {
    // render `response` to the DOM however you wish
    }); 
```

let observer = {
  next: function() {}, //生产者使用消费者的next()函数来推送数据给消费者。
  error: function() {}, //消费者收到该消息将忽略next消息
  complete: function() {} //消费者收到该消息将忽略next消息
}

Rx.Observable.fromPromise(promise) 转化promise函数：好处是promise可重复运行。
Rx.Observable.from([1, 2, 3]) 转化多值
Rx.Observable.of(2017) 转化单值
Rx.Observable.fromEvent(选择器,'click') 转化DOM事件

scan((a,b)=>a+b,0) 累计，他会每步next，reduce只最后一步next
take(0) 取前几个事件，0是不要。
first/last() 只要首/末值
do() 在所有next之前执行，debug用？好像是每步之前调用 
interval(1000) 定时发送0起步+1的无限序列
skip(10) 忽略前10个事件
delay(1000) 延迟整个事件1秒？好像是单个值
debounceTime(1000) 1秒内有新事件则取消该值并重新计时，
buffer(Rx.Observable.timer(1000)) 1秒的所有值推入数组。结束
bufferTime(1000) 1秒的所有值推入数组。
bufferCount(5) 把5个值推入数组，
merge()操作符内部会根据时间来做决定，合并起来的流中的事件就是无序的，交叉出现的。
concat() 合并流，有顺序。
map()合并流中里判断类型，return出相同格式的数据，适合封装不同事件的相同逻辑。
switch() 如果前面的return的是Rx.Observable，则内Observable会取代外Observable，新流的取代旧流。
mergeMap() 新内Observable不取代旧内Observable，二是合并成无序流。(去掉switch)
switchMap等同于map+switch concatMap同步顺序流(去掉switch)
flatMapLatest() 取消上一个请求，保留当前请求
```

const observable = Rx.Observable.create(observer => {
  observer.next(1);
  observer.next(2);
  observer.next(3);
  observer.complete();
});

const subscription = observable.subscribe(console.log);

```
subscribe函数的重载会自动为我们创建observer，并把console.log这个函数赋值给了next函数

### Ngnix
start ngnix 初始化
./nginx -s reload 重启配置

```
gzip  on; #测试压缩后大小
server {
	listen       80;
	server_name  192.168.11.92 localhost; 						  #多个入口
	location / {
		add_header 'Access-Control-Allow-Credentials' 'true';     #添加响应头
        add_header 'Access-Control-Allow-Origin' 'http://192.168.11.92:9001';# 只找到指定IP的跨域办法
        add_header 'Access-Control-Allow-Methods' 'POST,GET,PUT,OPTIONS,DELETE';  
        add_header 'Access-Control-Allow-Headers' 'accept, content-type,X-Requested-With'; 
	    add_header 'Content-Type' 'application/json';             
	    root D:/program/vuetest/mock; 							  #代理到本地文件夹
	}
	location /shop/ {
	    proxy_pass http://gym.gymcity.com.cn; 					  #反向代理到远程IP
	    rewrite ^/shop/(.*) /$1 break; 							  #正则匹配/shop/*
	}
}
```
在HTML5中，有些HTML元素为CORS提供了支持，如img、video新增了crossOrigin属性，属性值可以为anonymous或use-credentials。比如，canvas绘图要用到跨域图片，在JavaScript中要设置`img.crossOrigin="Anonymous";`
### axios
跨域先options,再发post,但是then回调只被执行了一次。
HTTP：
  1. application/json 发送json字符串
  2. application/x-www-form-urlencoded 发送键值对

data是要作为请求主体发送的数据，只适用于请求方法'PUT'，'POST'和'PATCH'
axios.defaults.withCredentials = true; 可以跨域携带cookie头
跨域机制是阻止了数据的获取，不是阻止了请求的发送。
```
axios.defaults.withCredentials = true;
let Proxys = axios.create({
  baseURL: "http://app.gym2.com/",
  headers: {
    'X-Requested-With': 'XMLHttpRequest',
    'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
  },
  transformRequest: [ //转formData格式。
    function(data) {
      let ret = "";
      for (let it in data) {
        ret +=
          encodeURIComponent(it) + "=" + encodeURIComponent(data[it]) + "&";
      }
      return ret;
    }
  ],
});
```