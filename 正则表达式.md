正则表达式基础： 无法梳理嵌套结构

##### 字符组

    1. 一个`[]`仅代表单个字符的范围。括号内出现的字符就是将要匹配的目标。顺序无所谓
    2. 范围表示法： `-`号代表ASCII码值范围所以有顺序 横线紧邻`［`或`[^`不需转义
    3. 排除字符组：`[^ ]` 它必须匹配到一个字符! ^必须紧临`[` `[^0-9][0-9]`能查A8，查不了8！
    4. 字符组简记法：等价于`[]`，既可单独写也可写在`[]`内 `\d`数字 `\w`数和字母_ `\s`空白 `\b`字符和空格的边界 大写等价于非`[^ ]`

##### 元字符

    1. 转义符：单\是转义，双\是自己，三\是自己和转义。 转义贪婪量词只需一个\{m,n}
    2. 有特殊含义的

##### 量词

    1. 字符组的长度 闭区间` \d{m,n} {m,} {0,n} {m}`
    2. 量词简记法：`+ {1,}  ？ {0,1}  * {0,}`
    3. 贪婪：`*`可配可不配选择配并记录状态，直到无词可配再回溯到最近位。导致`".*"`匹配出"ab"c" 适合区分文件路径和文件名
    4. 懒惰：`*？`原理与上相反，单个问号仍然是贪婪的，把问号加在任何量词后面转为懒惰量词。 懒惰遇到量词后的词会终结！贪婪遇到最后的该词才终结。

##### 分组

    1. 非捕获分组：`(?: )`作用是量词可应用在整体上了。
    2. 只用？限制各个部分会有缺陷，分组适合同时出现或同时不出现的情况。
    3. 多选：`(a|b|c)`只要有一个成功则匹配成功。思路：把出现情况按逻辑分类，每类单独写一个正则用|连接。 对顺序有要求
    4. 捕获分组：分组编号从左`1`到右的开括号算起。存储结果，适合提取src这种内嵌多种内容。 一个分组匹配多次存储的是最后一次。
    5. 反向引用：`<([^>]+)></\1>` 取得分组1匹配到的结果值，适合匹配重复数据。 \10如果有分组10就是\10，没有就是\1和0。
  断言：
    6. 匹配的是位置,不是字符。
    7. `\brow\b row`左右都必须是单词边界。适合缩小匹配范围.适合单词加标签高亮功能. 
    8. `^` 整个字符串的开始， `$` 整个字符串的结束,受多行模式影响。适合在每行开始结尾插入标签，文本转html。`^\s+`消除行头空格。
    9. 顺序环视：`(?! )`/`(?= )`字符之后不能/必须出现某字符 js只支持顺序环视。

##### 性能

    1. 捕获分组会存储匹配结果，非捕获分组不会。

#### 正则表达式例子

    1. `[0-9][1-9]{8}` 第1个字符是0-9，后8个字符是1-9
    2. `[\s\S]`/`(.|\n)`任意字符 [a-z]小写 [A-Za-z]大小写 [0-9]数字 [^a-z]除了小写 [^xy]除了xy [-0-9]横线和数字。
    3. `<[^>]+>`匹配所有标签 `"[^"]*"`匹配双引号 `<[^/][^>]*>`类似<div> `</[^>]+>`类似</script> `<[^>]+/>`类似<img />  `[^>]` 不是尖括号的任何字符，也就是到尖括号停止。`[^>]*`则是匹配大量非尖括号到>停止。 `[^>]*>`最后手动加个>
    4. https? s可有可无 ￥?100  
    5. `//.*`单行注释，单行不存在换行所以用点号
    6. `<script[\s>][\s\S]+?</script>`
    7. `.*/`URL路径 `[^/]*$`文件名
    8. `^(ab|cd)$`不能匹配abc    `^ab|cd$`可以
    9. `<(?!a)` <右边不能有a

##### JSapi

  //.test():只要有匹配则返true
  .match(//):匹配结果转数组 g拿不到()捕获分组数组 RegExp.$1可拿捕获分组
  .split(//):字符串拆分为数组
  //.exec():返匹配数组的第一项
  .search(//):返匹配的偏移
  .replace(//,""或(a,b)=>{}) a是匹配值，b是捕获组，匹配多个时回调执行多次。替换字符串时有许多变量可用！函数参数也有！