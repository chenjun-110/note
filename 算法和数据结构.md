###数据结构与算法javascript描述
二叉树：方便查询最大值和最小值。
函数是按值传递，想按引用传递，传入数组吧！
`a={n:1} b=a a={n:2}//b={n:1}` 变量被赋值的是整个对象，会创建对象。a变b不变。
`a.x = a = {n:2}; //a={n:2} b={n:1,x:{n:2}}` 点运算符优先级高先创建x:undefind属性 -> 再右到左生成新对象{n:2}给a -> 由于a.x是老对象，所以b会改变。
变量的引用是变量的别名。
####js数组
数组：一个存储元素的线性集合，可通过索引存取，计算元素偏移量。然而JS的数组略有不同，元素不必是同一种数据类型，它是一种特殊的对象，索引是属性内部被转换为字符串类型，所以效率上不如其他语言中的数组高。Array.isArray()可判断
数组整体赋值给另一个数组时，它是个引用。对象同理。
数组是否存在元素:indexOf
数组转字符串:join toString
数组切分:splice
添加首末:unshift push
删除首末:shift pop
添删中间:splice 解决了索引移动问题
数组排序:reverse sort
迭代:forEach every some reduce  map filter
多维数组: 二维行，三维列
```
Array.matrix = function(numrows, numcols, initial) {
	var arr = [];
	for (var i = 0; i < numrows; ++i) {
		var columns = [];
		for (var j = 0; j < numcols; ++j) {
			columns[j] = initial;
		}
	arr[i] = columns;
	}
	return arr;
}
```
按行访问:
```
for (var row = 0; row < grades.length; ++row) {
  for (var col = 0; col < grades[row].length; ++col) {
    total += grades[row][col];
}}
```
按列访问:
```
for (var col = 0; col < grades.length; ++col) {
  for (var row = 0; row < grades[col].length; ++row) {
    total += grades[row][col];
}}
```
####列表
列表：适用要排序的清单、元素不多、无需查找、存储无需顺序。不适合复杂结构。
实例：（轮播图,一条条的记录，从a列表移至b列表:天生有删除/追加/插入且索引都处理好了）
应有抽象特性：length append insert remove clear toString显示所有元素 getElement显示当前元素 front/end prev/next moveTo curPos当前位
迭代器遍历列表：
```
  for(names.front(); names.currPos() < names.length(); names.next()) {} //this.pos=0 this.pos ++this.pos
  for(names.end(); names.currPos() >= 0; names.prev()) {} //this.pos=length-1 this.pos --this.pos
```
迭代器只是用来在列表上随意移动，而不应该和任何为列表增加或删除元素的方法一起使用。只关心索引？

####栈
栈：后入先出，所以任何不在栈顶的元素都无法访问。性能高。
实例：栈元素可按顺序pop出来，倒序就压入B栈再pop。字符回文：入栈出栈后本来就是倒序的。页面前进后退是否用了2个栈？
应有抽象特性：length push pop peek预览栈顶 clear 

####队列
队列：先进先出，按顺序排队执行。
实例：待执行的一系列进程、任务池。基数排序：数组包含10个队列，按个位数入各列，出列，按十位数入各列，出列。
应有抽象特性：length push shift peek预览队头 clear front back toString empty
优先队列：遍历数组找出优先级最高的splice出来。

####链表
链表：js数组是对象，效率很低。除了随机访问，可代替一维数组。数组靠位置引用，链表只描述前后关系。增删效率很高，因为只需要修改前后项的指向。
结构：head->...node->null
双向链表：单向的删除节点需要查询前节点改引用，双向的本来就有前节点引用，所以删除性能更高。
链表移动方式：
```
while (!(currNode.next == null)) {
	currNode = currNode.next;
}
```
循环链表：尾节点的next指向head

####字典
字典：无关存储顺序，以键取值。Object就是字典的一种。
应有抽象特性：count() add find remove showAll clear

####散列
散列：快速插入、删除、取值。不适合查找。换键？把键值对存入数组。
散列字符键：散列数组长度应该是质数。因为取余运算length%key。键值映射为数组索引。 total += 37 * total + string.charCodeAt(i);
质数：大于1，不能被除自己和1以外的数整除。否则为合数。
散列整型键：

```
function betterHash(string) {
	const H = 37;
	var total = 0;
	for (var i = 0; i < string.length; ++i) {
		total += H * total + string.charCodeAt(i);
	}
	total = total % this.table.length;
	if (total < 0) {
		total += this.table.length-1;
	}
	return parseInt(total);
}
```
开链法：散列后的key相同就把值转数组。适合小数据。
线性探测法：有相同key就+1找到空位存储。适合大数据。

####Set
集合：无序，去重。
应有抽象特性：add show subset difference、

####二叉树
二叉树是一种特殊的树，通过将子节点的个数限定为 2，可以写出高效的程序在树中插入、查找和删除数据。
二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。
insert
	(1) 设根节点为当前节点。初始化左右为null
	(2) 如果待插入节点保存的数据小于当前节点，则设新的当前节点为原节点的左节点；反
	之，执行第 4 步。
	(3) 如果当前节点的左节点为 null，就将新的节点插入这个位置，退出循环；反之，继续
	执行下一次循环。
	(4) 设新的当前节点为原节点的右节点。
	(5) 如果当前节点的右节点为 null，就将新的节点插入这个位置，退出循环；反之，继续
	执行下一次循环。
中序遍历：按值升序访问。从左树-根-右树。
先序遍历：从根到下。上->中左(-左右)->中右(-左右)
后序遍历：从下到根。左->右->中左->(...中右)->上 
remove
	如果待删除节点是叶子节点（没有子节点的节点），那么只需要将从父节点指向它的链接
	指向 null。
	如果待删除节点只包含一个子节点，那么原本指向它的节点久得做些调整，使其指向它的
	子节点。
	最后，如果待删除节点包含两个子节点，正确的做法有两种：要么查找待删除节点左子树
	上的最大值，要么查找其右子树上的最小值。这里我们选择后一种方式。

####图
图：由边的集合及顶点的集合组成。 如果一个图的顶点对是方向有序的，则可以称之为有向图。
路径：长度用第一个顶点到最后一个顶点之间边的数量表示。由指向自身的顶点组成的路径称为环，环的长度为 0。如果两个顶点之间有路径，那么这两个顶点就是强连通的
圈：是至少有一条边的路径，且第一个顶点和最后一个顶点相同。 没有重复边或顶点是简单圈，否则为平凡圈。
实例：
1. 交通流量建模：顶点表示路口，边表示街道。加权的边表示限速或者车道数。
2. 航空：机场看成顶点，航线看作边，加权的边表示航班成本或距离。
图算法的效率很大程度上取决于用来表示这个图的数据结构。
领接表：把相邻顶点的key保存为自己key的value。
