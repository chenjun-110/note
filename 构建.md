####npm
查看文件：`ls`
npm install/i 包安装到node_modules目录 不会修改package.json所以需手动配置
-S/--save 把版本号添加到package.json的dependencies(产品依赖)
-D/--save-dev 把版本号添加到package.json的devDependencies(开发依赖)
--save-optional 添加到optionalDependencies
--production 只下载dependencies中的产品模块
npm info 检测包历史更新
npm outdated 检测已安装包是否可更新
npm update 更新包
npm un/uninstall 删除包
npm init -y 生成package.json，创建模块的前提
npm adduser 模块注册用户
npm publish 发布模块
npm install -g cnpm --registry=https://registry.npm.taobao.org 淘宝npm
cnpm install 淘宝下载
####Webpack2
定义：一种管理依赖的工具。
安装:1.`$ npm install webpack -g` 2.在对应文件夹中`npm init` 3.`npm install webpack --save-dev `
命令行界面：Asset文件 Chunks分块
打包命令：`webpack a.js b.js` 先创建2个js,把a.js打包进b.js。a.js里用require引入依赖js。b.js中__webpack_require__(0)意思是依赖索引0的文件。
引入样式loader:`npm install css-loader style-loader --save-dev`可在js中依赖css文件require('style-loader!css-loader!./d.css');前者是把css插入head内后者是css依赖在js内，可在b.js的exports.push([])找到。


`webpack --help`各种参数，参数的调用在打包命令的后面
  --module-bind 'css=style-loader!css-loader' js依赖css不用再重复写style-loader!css-loader！了
  --watch 不用重复发打包命令，修改文件就自动打包
`webpack --config xxx.js` 用另一份配置打包
`webpack -p` 一次生产,压缩混淆脚本(可压缩模块的内联js，无法压缩真内联js)
`webpack --watch` 监听变动自动打包
`webpack -d`资源地图，模块被打包去向
加载CoffeeScript：`npm install babel-loader coffee-loader`
加载JSX+ES6：`npm install babel-core babel-preset-es2015 babel-preset-react`

**webpack.config.js**参数：
entry：数组形式是不依赖，对象形式是为多个html生成多个包(属性为js名)
output:
  path必须是绝对路径格式为`\\`
  filename：[name]是多个包名，[chunkhash]只有改变文件才换hash号
  publicPath:上线url，以它开头。

module数组:先处理右边(下方)。
  loaders：
     1.例子：{test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}
     多个loader之间用!连接。loaders都是用npm加载`npm install url-loader -save-dev`,其中的text正则查找资源，url-loader可换成其它加载器。?limit=8192表示超过8kb使用url-loader来映射到文件，否则转为data url形式。
     2.{test:"/\.js$/",loader:"babel-loader"}
     3.`exclude:path.resolve(__dirname,'node_modules')`不搜索该文件夹，解析绝对路径(要先require('path')) `__dirname`当前绝对路径
  postcss:[]


插件：npm install xxx-plugin --save-dev 需变量引入require，必须驼峰全名
html-webpack-plugin:压缩、嵌入html、模板引擎。
  template模板，inject:'head'包插入位置
  取值符：`<%= 变量.options.属性 %>`将它插入在模板html中，在配置文件里定义属性和值可显示到html中。
  循环符：`<% for(var key in 变量.options.属性) { %>`内容`<% } %>` 里面也是可以访问取值的。JSON.stringify(变量files)//
  minify:压缩。removeComments删除html注释，collapseWhitespace删除html空格
  chunks:[]指定当前html要包含的js包或模块,多个页面需调用多个new。
  excludeChunks:同上，加载除了xx的包。
```
//下面写在模板html中。
<script type="text/javascript"> //把js包插入到head内联script内
<%= 
	compilation.assets[   //wp源码方法
	   htmlWebpackPlugin.files.chunks.a.entry.substr(htmlWebpackPlugin.files.publicPath.length) //把a包的entry链接(跳过上线url)插进来
	].source()    //wp源码方法
%></script>
                 //下面这个插在body中的外联js
<% for(var k in htmlWebpackPlugin.files.chunks){ %> //循环
  <% if (k !== 'a')	{ %>   //只要不是a模块就执行
<script type="text/javascript" src="<%= htmlWebpackPlugin.files.chunks[k].entry %>"></script>  
  <% } %>
<% } %> //注意要设置inject:false保证不自动插入模块，因为这里已经插了。
```
安装loders
安装babel
安装preset-latest:`npm install --save-dev babel-preset-latest`
**package.json**参数：
scripts中:设置webpack配置文件和参数
启用配置文件`npm run webpack`
设置babel的预设:` "babel":{"presets":["latest"]}`与此同时在config中设置module。



css后处理插件：`npm install postcss-loader --save-dev`
css加前缀：`npm install autoprefixer --save-dev`需要依赖postcss
用法：在根目录新建()
postcss.config.js配置`module.exports={plugins:[require('autoprefixer')({browsers:["last 5 versions"]})]} ` 
webpack.config.js配置`rules:[{test:/\.css$/,use:['style-loader','css-loader?importLoaders=1','postcss-loader']}]`

处理图片：file-loader
tpl模板中引用相对路径图片会出错:1.用绝对路径 2.src=`${require('相对路径')}`
压缩图片：image-loader`$ npm install image-webpack-loader --save-dev`

搜索文件：resolve:{extensions：['.js']}
从模块目录查找：require('lodash')
按相对路径查找静态资源：require('./bootstrap.css'); 也可以把图片url放里面并赋值给img.src


export default Layer;这是ES6导出Layer函数

**loader**
svg:rules[{test:/\.svg$/,loader:"url-loader"}]
png:src={require('./girl.png')} {test:/\.png$/,loader:"url-loader?limit=9999&name=[name].[ext]"}



**babel**
项目根目录配置文件.babelrc步骤：
<<<<<<< HEAD
1.npm install --save-dev babel-preset-es2015 npm install --save-dev babel-preset-react
2.设置.babelrc {"presets": ["es2015","react",],"plugins": []}

安装命令行步骤：
1.npm install --save-dev babel-cli
2.设置package.json {"devDependencies": {"babel-cli": "^6.0.0"},"scripts": {"build": "babel src -d lib"}}
3.转码 npm run build  就转到lib文件夹去了

本地离线jsx转js：
安装`npm install -g react-tools` 把src目录转换到build`jsx --watch src/ build/`



=======
1.npm install --save-dev babel-preset-es2015 
  (最新转码规则:babel-preset-latest React转码:babel-preset-react 按提案区分的转码：babel-preset-stage-0/1/2/3)
2.配置.babelrc `{"presets": ["es2015","react"],"plugins": []}`它是所有功能的前提！

命令行步骤：
npm install -g babel-cli
转码单文件：babel a.js -o b.js
转码整个目录：babel src_a -d src_b //这2个是全局转码，下面是项目转码
1.npm install --save-dev `babel-cli`
2.设置package.json {"devDependencies": {"babel-cli": "^6.0.0"},"scripts": {"build": "babel src -d lib"}}  //转码整个目录
3.转码 npm run build  

引入步骤：仅适合开发时
npm install --save-dev `babel-register`
require("babel-register"); 先引入它，所有require命令都会被转码
require("./index.js");

babel-core:适合在node里用，调用babel的api转码指定代码。
babel默认不转码ES6-API，需引入babel-poplyfill
>>>>>>> e92839421b666749e2781ea698fea3281dcc7901

